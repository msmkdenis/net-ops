# Лабораторная работа: Docker-трафик + Suricata (NFQUEUE/iptables)

Ниже — теоретические объяснения **что** и **зачем** делаем, по этапам.

---

## 1) Настройка ядра для фильтрации мостов Docker

- **Почему это нужно**
  - Docker соединяет контейнеры через Linux bridge (`docker0`) и пары `veth`.
  - Этот трафик часто проходит как **bridged (L2 через мост)**, и без специальных настроек ядра он может **не попадать в netfilter/iptables** так, как ожидается.
  - Чтобы Suricata могла анализировать/блокировать Docker-трафик через iptables, надо “поднять” bridged-пакеты в netfilter-хуки.

- **Загрузка модуля `br_netfilter`**
  - `br_netfilter` включает интеграцию Linux bridge с netfilter.
  - Без него правила iptables могут не применяться к трафику внутри docker bridge и через него.

- **Персистентная загрузка модуля**
  - Добавление модуля в автозагрузку (`/etc/modules-load.d/...`) нужно, чтобы после перезагрузки система не “забывала” модуль.

- **sysctl: `net.bridge.bridge-nf-call-iptables=1` / `...ip6tables=1`**
  - Включает обработку bridged IPv4/IPv6 пакетов через iptables/ip6tables.
  - Это ключевой переключатель: без него цепочки типа `FORWARD`/`DOCKER-USER` могут не видеть нужный поток.

- **Применение sysctl без ребута**
  - Применяем параметры сразу (чтобы лабораторная проверялась без перезагрузки).

---

## 2) Создание и добавление базовых правил (Suricata)

- **Зачем начинать с базовых правил**
  - Они дают быстрый и понятный тест:
    - **drop** → реально блокируем трафик (проверка inline IPS).
    - **alert** → фиксируем события в логах без блокировки (проверка IDS/детекта).

- **Отдельный файл локальных правил (`local.rules`)**
  - Практика DevOps/SECOPS: свои правила держим отдельно от “пакетных/обновляемых”, чтобы обновления не затирали изменения.

- **Пример: `drop icmp ...`**
  - **Что делает:** отбрасывает ICMP (например, `ping`).
  - **Зачем:** это простой “smoke test” — сразу видно, что трафик реально проходит через Suricata inline.

- **Пример: `alert http ... flow:to_server`**
  - **Что делает:** ловит HTTP-запросы, направленные к серверу (to_server).
  - **Зачем:** демонстрирует анализ L7 (app-layer) и корректную запись событий в `eve.json`.

- **`sid` и `rev`**
  - `sid` — уникальный идентификатор правила (важен для сопровождения, исключений, корреляции).
  - `rev` — версия правила (удобно при изменениях и аудите).

---

## 3) Настройка iptables для перехвата Docker-трафика

- **Основная идея**
  - Мы хотим, чтобы Docker-трафик попадал в Suricata **inline**, а Suricata возвращала вердикт (accept/drop).
  - Для этого используем связку:
    - **iptables → NFQUEUE** (пакеты отправляются в очередь ядра)
    - **Suricata читает NFQUEUE** и принимает решение

- **Почему используем цепочку `DOCKER-USER`**
  - Docker сам управляет iptables-правилами (NAT/forward и служебные цепочки).
  - `DOCKER-USER` — официальная точка расширения, где пользовательские правила применяются **до** Docker-логики в FORWARD.
  - Это снижает риск, что Docker “обойдёт” или “перезапишет” наши правила.

- **Правило `NFQUEUE --queue-num 1`**
  - Отправляет соответствующий трафик в очередь **№1**.
  - Номер очереди должен совпадать с тем, что указано в запуске Suricata (`-q 1`).

- **`--queue-bypass` (fail-open)**
  - Если Suricata не запущена или очередь недоступна, трафик **не блокируется** и идёт дальше.
  - Плюс: не “положим” сеть при ошибке/перезапуске Suricata.
  - Минус: при падении Suricata IPS временно отключится (нормально для учебного стенда).

- **Идемпотентность правил**
  - Перед вставкой часто удаляют возможный дубликат (или используют “delete if exists”), чтобы повторный прогон не плодил одинаковые правила.

- **Сохранение правил**
  - По умолчанию iptables живут до перезагрузки.
  - Сохранение (например через `netfilter-persistent`) делает перехват устойчивым к reboot.

---

## 4) Получение необходимых прав и настройка systemd

- **Почему нужны привилегии**
  - Работа с NFQUEUE и сетевым стеком требует прав уровня ОС.
  - Без них Suricata может не открыть очередь, не применить нужные операции или работать нестабильно.

- **Capabilities вместо постоянного root**
  - `setcap cap_net_admin,cap_net_raw+ep /usr/bin/suricata`
  - `cap_net_admin` — сетевые административные операции (часто нужно для netfilter-взаимодействий).
  - `cap_net_raw` — raw-сокеты и низкоуровневые сетевые операции.
  - Это безопаснее, чем держать сервис полностью root’ом (хотя конкретная модель зависит от политики стенда).

- **systemd override (изменение запуска)**
  - Пакетный unit Suricata может быть настроен под IDS (например `-i eth0`).
  - В лабораторной нужен inline через NFQUEUE → запуск должен быть с `-q 1`.
  - Override позволяет:
    - сбросить старый `ExecStart`
    - задать корректный `ExecStart` под NFQUEUE
  - Это делает запуск воспроизводимым и совпадающим с iptables `--queue-num 1`.

---

## Итоговая логика

- Ядро + `br_netfilter` + sysctl → **делают Docker bridged-трафик видимым для iptables**  
- iptables `DOCKER-USER -> NFQUEUE` + Suricata `-q 1` → **даёт inline IDS/IPS (alert/drop) на Docker-трафик**
